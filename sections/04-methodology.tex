\section{Metodologia}

Nesta seção, será apresentada a metodologia adotada para o desenvolvimento dos experimentos de benchmark comparativo entre diferentes tecnologias de computação paralela aplicadas ao processamento de imagens.

\subsection{Estudo e Experimentos}

A metodologia adotada será baseada nos experimentos de \cite{Dantas2015opencl} que utiliza a biblioteca VisionGL com operadores de processamento de imagens implementados em OpenCL como base para análise de desempenho de diferentes tecnologias de computação paralela. Repetiremos o experimento com estas tecnologias:
\begin{itemize}
	\item SYCL através do compilador AdaptiveCPP.
	\item CUDA com Julia através da biblioteca CUDA.jl.
	\item OpenCV com Python através da biblioteca opencv-python.
	\item OpenCL através da biblioteca VisionGL.
	\item MATLAB Parallel Computing Toolbox.
\end{itemize}

Desenvolveremos os operadores de processamento de imagens conforme descritos nas \Crefrange{eq:grayscale}{eq:dilation} para as tecnologias que buscamos analisar os desempenhos.

A foi feito um \textit{fork} da biblioteca VisionGL\footnote{\url{https://github.com/ddantas/visiongl}} para estudo da estrutura do projeto e desenvolvimento dos operadores lógicos em outras tecnologias. O \textit{fork} este presente no repositório do GitHub\footnote{\url{https://github.com/jusqua/visiongl}}.

\subsection{Recursos Utilizados}

As especificações do ambiente de trabalho utilizado no momento da realização dos experimentos:
\begin{itemize}
	\item \textbf{Hardware:}
	      \begin{itemize}
		      \item Processador: Intel Core i9-14900K
		      \item Memória RAM: 32GB DDR5
		      \item Placa de Vídeo: NVIDIA GeForce RTX 5060 Ti 16GB
	      \end{itemize}
	\item \textbf{Software:}
	      \begin{itemize}
		      \item Sistema Operacional: Fedora Linux 42
		      \item Kernel: 6.17.5
		      \item GPU Driver: 580.95.05
		      \item CUDA Driver: 13.0.88
		      \item OpenCL: 3.0
		      \item Compilador C++: Clang 20.1.8
		      \item Compilador SYCL: AdaptiveCPP (commit 3992a120)
		      \item Runtime Julia: 1.12.1
		      \item Runtime Python: 3.13.9
		      \item Runtime MATLAB: 25.1.0.2943329
	      \end{itemize}
	\item \textbf{Bibliotecas:}
	      \begin{itemize}
		      \item VisionGL: (commit 4507817)
		      \item OpenCV: 4.10.0
		      \item CUDA.jl: 5.9.2
	      \end{itemize}
\end{itemize}

\subsection{Estrutura do Benchmark}

A imagem de teste utilizada nos experimentos é a mostrada na \Cref{fig:fundus} com dimensões de $3504x2336$ píxeis e 3 canais de cor. A imagem foi escolhida por conter por ser grande o suficiente para ter um atraso significativo no processamento.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\linewidth]{images/fundus.jpg}
	\caption{Imagem de olho com retinopatia diabética. Obtida em: \url{https://www5.cs.fau.de/research/data/fundus-images/}}
	\label{fig:fundus}
\end{figure}

Para o operador de erosão~\ref{eq:erosion} utilizamos elementos estruturantes distintos:
\begin{enumerate}
    \item cruz 3x3:
        $\begin{bmatrix}
            0 & 1 & 0 \\
            1 & 1 & 1 \\
            0 & 1 & 0
        \end{bmatrix}$;
    \item quadrado 3x3:
        $\begin{bmatrix}
            1 & 1 & 1 \\
            1 & 1 & 1 \\
            1 & 1 & 1
        \end{bmatrix}$;
    \item quadrado 3x3 separado:
        $\begin{bmatrix}
            1 & 1 & 1
        \end{bmatrix}
        \cross
        \begin{bmatrix}
            1 \\
            1 \\
            1
        \end{bmatrix}$.
\end{enumerate}

Para o operador de convolução~\ref{eq:convolution} utilizamos \textit{kernels} de desfoque gaussiano com diferentes proporções e desenvolvimentos:
\begin{enumerate}
    \item 3x3;
    \item 3x3 separado;
    \item 3x3 injetado estaticamente no operador;
    \item 5x5;
    \item 5x5 separado.
\end{enumerate}

Para garantir comparações justas entre as tecnologias, foi desenvolvida a seguinte estrutura de benchmark que:
\begin{enumerate}
	\item carrega a imagem de teste, elementos estruturantes e \textit{kernels} na memória do dispositivo;
	\item mede o tempo médio de execução da transferência de dados entre CPU e GPU, entre GPU e GPU, e o tempo dos operadores em 10000 iterações;
	\item realiza o aquecimento da GPU executando cada operador uma vez antes das medições;
	\item salva as imagens para comparação dos resultados.
\end{enumerate}

Todos os experimentos foram executados com a mesma imagem de teste para avaliar o comportamento de escala de cada tecnologia. Os resultados foram salvos em formato estruturado para análise posterior. Os experimentos e simulações deste trabalho que foram realizados estão presentes no repositório do GitHub\footnote{\url{https://github.com/jusqua/dip-benchmark}}.
