\section{Desenvolvimento}

Nesta seção, serão apresentados os detalhes de implementação dos operadores de processamento de imagens em cada uma das tecnologias avaliadas. Cada subseção descreve as particularidades e desafios encontrados durante o desenvolvimento em cada tecnologia.

\subsection{Implementação dos operadores para SYCL}

Para cada operador, foi criado um \textit{functor} para servir como \textit{kernel} de execução. O gerenciamento de memória foi realizado por meio de USM, que não abstraem a transferência de dados entre CPU e GPU. Para o desenvolvimento do \textit{kernel} para ser executado utilizamos a estrutura descrita em \ref{lst:sycl-kernel-struct}.

\begin{lstlisting}[caption={Estrutura de um \textit{functor} para ser utilizado como \textit{kernel} para a fila SYCL.}, label={lst:sycl-kernel-struct}]
class Kernel {
protected:
  uint8_t* input;
  uint8_t* output;
  size_t width;
  size_t height;
  size_t channels;

public:
  Kernel(uint8_t* in, uint8_t* out, size_t w, size_t h, size_t c)
    : input(in), output(out), width(w), height(h), channels(c) {}

  void operator()(sycl::nd_item<2> item) const {
    // prelude
    size_t y = item.get_global_id(0);
    size_t x = item.get_global_id(1);
    if (y >= height || x >= width) return;

    /* operator logic */
  }
};
\end{lstlisting}

A seguir será apresentado a implementação da base de cada \textit{kernel} dos operadores em C++.

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:inversion}.}, label={lst:sycl-inversion-kernel}]
for (size_t c = 0; c < channels; ++c) {
  size_t index = (y * width + x) * channels + c;
  output[index] = 255 - input[index];
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:grayscale}.}, label={lst:sycl-grayscale-kernel}]
size_t pixel_idx = (y * width + x) * channels;
uint8_t gray = static_cast<uint8_t>(
  0.0722f * input[pixel_idx] +      // B
  0.7152f * input[pixel_idx + 1] +  // G
  0.2126f * input[pixel_idx + 2]    // R
);

for (size_t c = 0; c < channels; ++c)
  output[pixel_idx + c] = gray;
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:thresholding}.}, label={lst:sycl-threshold-kernel}]
for (size_t c = 0; c < channels; ++c) {
  size_t index = (y * width + x) * channels + c;
  output[index] = (input[index] > threshold) ? max_value : 0;
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:erosion}.}, label={lst:sycl-erosion-kernel}]
for (size_t c = 0; c < channels; ++c) {
  uint8_t result = 255;

  for (size_t my = 0; my < mask_height; ++my) {
    for (size_t mx = 0; mx < mask_width; ++mx) {
      bool mask_val = mask[my * mask_width + mx];
      if (!mask_val) continue;

      int iy = y + my - mask_height/2;
      int ix = x + mx - mask_width/2;

      if (iy < 0) iy = -iy;
      if (ix < 0) ix = -ix;
      if (iy >= static_cast<int>(height)) iy = 2*height-iy-1;
      if (ix >= static_cast<int>(width)) ix = 2*width-ix-1;

      uint8_t pixel = input[(iy*width+ix)*channels+c];
      result = sycl::min(result, pixel);
    }
  }

  output[(y*width+x)*channels+c] = result;
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:convolution}.}, label={lst:sycl-convolution-kernel}]
for (size_t c = 0; c < channels; ++c) {
  float sum = 0.0f;

  for (size_t ky = 0; ky < kernel_height; ++ky) {
    for (size_t kx = 0; kx < kernel_width; ++kx) {
      int iy = y + ky - kernel_height/2;
      int ix = x + kx - kernel_width/2;

      if (iy < 0) iy = -iy;
      if (ix < 0) ix = -ix;
      if (iy >= static_cast<int>(height)) iy = 2*height-iy-1;
      if (ix >= static_cast<int>(width)) ix = 2*width-ix-1;

      float kernel_val = kernel[ky*kernel_width+kx];
      uint8_t pixel = input[(iy*width+ix)*channels+c];
      sum += kernel_val * pixel;
    }
  }

  int result = static_cast<int>(sum + 0.5f);
  result = sycl::clamp(0, result, 255);
  output[(y*width+x)*channels+c] = static_cast<uint8_t>(result);
}
\end{lstlisting}

\subsection{Implementação dos operadores para CUDA}

A implementação em CUDA utilizou o pacote CUDA.jl para a linguagem Julia, que fornece uma interface de alto nível para programação CUDA. Para o desenvolvimento do \textit{kernel} para ser executado utilizamos a estrutura descrita em \ref{lst:cudajl-kernel-struct}.

\begin{lstlisting}[caption={Estrutura do \textit{kernel} para fila CUDA.jl.}, label={lst:cudajl-kernel-struct}]
@inline function kernel!(input, output, width, height, num_channels)
    # prelude
    x = (blockIdx().x - 1) * block_size + threadIdx().x
    y = (blockIdx().y - 1) * block_size + threadIdx().y
    if !(1 <= x <= width && 1 <= y <= height &&) return end

    # operator logic
    # ...

    # epilogue
    return
end
\end{lstlisting}

A seguir será apresentado a implementação da base de cada \textit{kernel} dos operadores em Julia.

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:inversion}.}, label={lst:cudajl-inversion-kernel}]
for c in 1:num_channels
  output[c,x,y] = 1.0f0 - input[c,x,y]
end
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:grayscale}.}, label={lst:cudajl-grayscale-kernel}]
gray = 0.2126f0 * input[1,x,y] + 0.7152f0 * input[2,x,y] + 0.0722f0 * input[3,x,y]
for c in 1:num_channels
  output[c,x,y] = gray
end
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:thresholding}.}, label={lst:cudajl-threshold-kernel}]
for c in 1:num_channels
  output[c,x,y] = input[c,x,y] > threshold_value ? 1.0f0 : 0.0f0
end
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:erosion}.}, label={lst:cudajl-erosion-kernel}]
px = [0.0f0, 0.0f0, 0.0f0, 0.0f0]
px_sum = 0.0f0
new_px_sum = 0.0f0
for c in 1:num_channels
  px[c] = input[c,x,y]
end

for my in -m_half_height:m_half_height
  for mx in -m_half_width:m_half_width
    ix = x + mx
    iy = y + my
    if !(1 <= ix <= width && 1 <= iy <= height && mask[my+m_half_height+1, mx+m_half_width+1] == 1) continue end

    for c in 1:num_channels
      new_px_sum += input[c,ix,iy]
    end
    if (new_px_sum > px_sum)
      for c in 1:num_channels
        px[c] = input[c,ix,iy]
      end
      px_sum = new_px_sum
    end
  end
end

for c in 1:num_channels
  output[c,x,y] = px[c]
end
\end{lstlisting}

\begin{lstlisting}[caption={Implementação do operador para \Cref{eq:convolution}.}, label={lst:cudajl-convolution-kernel}]
sum = [0.0f0, 0.0f0, 0.0f0, 0.0f0]
for ky in -k_half_height:k_half_height
  for kx in -k_half_width:k_half_width
    ix = x + kx
    iy = y + ky
    if !(1 <= ix <= width && 1 <= iy <= height) continue end

    for c in 1:num_channels
      sum[c] += input[c,ix,iy] * kernel[ky+k_half_height+1, kx+k_half_width+1]
    end
  end
end

for c in 1:num_channels
  output[c,x,y] = sum[c]
end
\end{lstlisting}

\subsection{Implementação dos benchmarks}

% ...
